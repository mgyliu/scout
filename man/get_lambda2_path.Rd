% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lambda_path.R
\name{get_lambda2_path}
\alias{get_lambda2_path}
\title{Get the lambda2 path dynamically, from the data. The data is assumed to
be standardized already}
\usage{
get_lambda2_path(
  X,
  Y,
  X_cov,
  p2,
  nlambda = 100,
  lambda_min_ratio = 0.001,
  desc_frac = 0.8,
  max_iter = 100
)
}
\arguments{
\item{X}{data matrix (n x p)}

\item{Y}{data matrix (n x 1)}

\item{p2}{type of regularization in second scout step. Can be NULL or 1.
Ignored if greater than 1}

\item{nlambda}{how many lambda2's do you want to regularize over?}

\item{lambda_min_ratio}{smallest value for lambda2 as a fraction of
lambda2_max.}

\item{desc_frac}{by how much to multiply lambda_max when tuning it in
bisection search for the "ideal" lambda_max}

\item{max_iter}{maximum number of iterations to use to find the lowest
lambda_max in bisection search}

\item{cov_x}{estimate for covariance matrix of X. This should be the $w
portion of the glasso::glasso output. This argument is needed since
lambda2_max depends on the step 1 result using lambda1}
}
\description{
This function does not depend on lambda1. Empirically, the lowest possible
lambda2_max is the same regardless of lambda1. lambda1 controls the cov_x
value (coming form GLASSO). But we are just using a regular cov_x estimator
and the lambda2_max is the same.
}
